#!/bin/bash

##
## Splits and concats video clips using ffmpeg.
##
## @author Ondrej Zizka
##

. ~/sc/vid/_common.lib.sh

set -e
set +x
VIDEO_FILE="$1"
TIMES_FILE="$2"
BASE_NAME=`basename "$VIDEO_FILE"`
BASE_NAME="${BASE_NAME%.*}"
SUFFIX=${VIDEO_FILE##*.}

if [ "$#" -lt 2 ] ; then echo -e "\nExpecting input video file and input text file with times to split and concat - '[m]m:ss [m]m:ss\\\\n' per part.\n"; exit; fi

echo -e "\n\n   Splitting $VIDEO_FILE as per $TIMES_FILE\n\n";
rm -rf tmpVideoSplit
mkdir -p tmpVideoSplit
cd tmpVideoSplit


#while IFS='' read -r SLINE; do ## || [[ -n $SLINE ]] 
IFS=$'\n'
PART_INDEX=0;
for SLINE in `cat ../$TIMES_FILE`; do
  echo SLINE: $SLINE
  PART_INDEX=$((PART_INDEX+1));
  T1=`echo "$SLINE" | cut -d' ' -f1`
  T2=`echo "$SLINE" | cut -d' ' -f2`
  CLIP=`echo ~/sc/vid/clip`
  #CMD="$CMD" "../$VIDEO_FILE" "$T1" "$T2"
  echo -e "\n   Running" $BLUE "$CLIP" "../$VIDEO_FILE" "$T1" "$T2" "$NOCOLOR\n"
  #bash -c "$CLIP" "../$VIDEO_FILE" "$T1" "$T2" part-$PART_INDEX.$SUFFIX
  #exec -c "$CLIP" "../$VIDEO_FILE" "$T1" "$T2" part-$PART_INDEX.$SUFFIX
  `"$CLIP" "../$VIDEO_FILE" "$T1" "$T2" part-$PART_INDEX.$SUFFIX` ### There's some bug in bash which cripples the SLINE value when using `read`.
#done < "../$TIMES_FILE"
done

#exit  ###
cd ..

NEW_NAME="$BASE_NAME"-splitConcat.$SUFFIX

#find tmpVideoSplit/ -maxdepth 1 -type f -iname '*.mp4' -o -iname '*.mov' -o -iname '*.avi' -exec echo file \'{}\' \; > tmpVideoSplit/.list.txt 
find tmpVideoSplit/ -maxdepth 1 -type f -not -iname '*.txt' -exec echo {} \; > tmpVideoSplit/list.txt 
~/sc/vid/concat tmpVideoSplit/list.txt # "$VIDEO_FILE"


touch "$NEW_NAME" -r "$VIDEO_FILE"

